# How to Create Custom OCF Applications #

The IoTivity-Lite development kit enables users to automatically generate
code for an OCF Server. This is a great starting point for developing an OCF
application. This guide describes how to generate such applications and
import them into the Cascoda SDK.

## Prerequisites ##

In order to follow this guide, you must set up the IoTivity-Lite SDK as
described in the [IoTivity-Lite Device Simulation
Guide.](https://iotivity.org/getting-started-iotivity-device-simulation) We
recommend going through the entire guide so that you can gain an
understanding of how OCF applications work in general. If you have the
necessary hardware, we also recommend going through the [IoTivity-Lite
Raspberry Pi
Guide](https://iotivity.org/getting-started-iotivity-raspberry-pi-kit) before
proceeding.

## Generating an Application ##

After running the `./gen.sh` script, as described in the Device Simulation
guide, you should find the auto-generated source files inside the
`device_output/code` folder. The files that need to be imported into the
Cascoda SDK are `server_introspection.dat.h`, and `simpleserver.c`

`server_introspection.dat.h` contains introspection data used by an OCF
server in order to advertise its capabilities. It describes the various
resources present on the server, and gives information on how to use them.
Having accurate introspection data is necessary in order to pass OCF
certification. The introspection data is generated based on the
`example.json` file in the top-level `iot-lite` directory. It is stored as
CBOR data, and can be translated to a human-readable format using
[cbor.me](http://cbor.me/).

`simpleserver.c` contains the actual behaviour of the server, which enables
it to respond to requests & updates. When developing an end product, the
source file needs to be modified to communicate with the hardware (such as a
relay to turn on a smart light, or various sensors within a sensing device).
The comments near the top of the file contain information on how to do this.

You can find more information about the contents of these files within [OCF's
documentation of the template used to generate
them.](https://openconnectivityfoundation.github.io/swagger2x/src/templates/IOTivity-lite/)
Additionally, more information on the IoTivity-Lite SDK [can be found
here](https://openconnectivity.github.io/IOTivity-Lite-setup/).

## Importing an Application into the Cascoda SDK ##

Some changes to the autogenerated `simpleserver.c` file are required. Within
the `ocf-light` example, they are commented as "Cascoda additions".
Searching for "Cascoda" within that file will locate all of these changes. You
may also want to modify the request handlers so that they access hardware,
for e.g. relaying sensor measurements.

You must also link `simpleserver.c` against a file that provides a `main`
function, as the automatically generated one is unsuitable for embedded
platforms. You may use the ones we have used for our examples
(`sleepy_main.c` or `wakeful_main.c`) or write your own.

## Customizing an Application using DeviceBuilder ##

By default, the IoTivity SDK generates an OCF Server intended to control a
light, with a `oic.r.switch.binary` resource. If you would like to generate a
different type of device, you must change the device type inside `gen.sh`, as
well as the list of resources within `example.json`. The list of resources
must match the device type of the server in order to pass OCF certification.
A list of the mandatory resources for each standard OCF device type can be
found within the [OCF Device
Specification](https://openconnectivity.org/developer/specifications/).

## Optimising Flash and RAM utilisation ##

There are several features of OpenThread that can be disabled for
further resource gains. These are controlled by variables within the
CMakeCache.txt file, also accessible through the `ccmake .` command, to be
called inside your build directory.

To free up as much memory and flash as possible, the variables that should be
set to `OFF` are as follows:

- `OT_BORDER_AGENT`
- `OT_BORDER_ROUTER`
- `OT_COAP`
- `OT_COMMISSIONER`
- `OT_DHCP6_SERVER`
- `OT_MAC_FILTER`
- `OT_SERVICE`
- `OT_UDP_FORWARD`

Note that other targets within the Cascoda SDK may not build if the
OpenThread configuration is changed from the default one.

Additionally, you can gain more RAM by reducing the number of 128-byte
buffers used by OpenThread. `OPENTHREAD_CONFIG_NUM_MESSAGE_BUFFERS` is the
CMake Cache variable that controls this. Note that this will reduce network
performance, and it must not be set lower than 44.
