/**
 * @file tempsense_evbme.c
 * @brief Chili temperature sensing EVBME functions
 * @author Wolfgang Bruchner
 * @date 14/09/15
 *//*
 * Copyright (C) 2016  Cascoda, Ltd.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
#include <stdio.h>
#include "cascoda-bm/cascoda_evbme.h"
#include "cascoda-bm/cascoda_interface.h"
#include "cascoda-bm/cascoda_types.h"
#include "ca821x_api.h"

#include "tempsense_app.h"
#include "tempsense_evbme.h"
#if APP_USE_DEBUG
#include "tempsense_debug.h"
#endif /* APP_USE_DEBUG */

static int TEMPSENSE_mode_button_pressed(void);
static int TEMPSENSE_usb_present_changed(void);
static int TEMPSENSE_reinitialise(struct ca821x_dev *pDeviceRef);

/******************************************************************************/
/***************************************************************************/ /**
 * \brief Initialise Chili module for temperature sensing app
 *******************************************************************************
 * \param status - EVBME status
 *******************************************************************************
 ******************************************************************************/
void TEMPSENSE_Initialise(u8_t status, struct ca821x_dev *pDeviceRef)
{
	button1_pressed     = TEMPSENSE_mode_button_pressed;
	usb_present_changed = TEMPSENSE_usb_present_changed;
	app_reinitialise    = TEMPSENSE_reinitialise;

	if (status == CA_ERROR_FAIL)
	{
		APP_INITIALISE = 0;
		BSP_LEDSigMode(LED_M_SETERROR);
#if APP_USE_DEBUG
		APP_Debug_Error(0x10);
#endif /* APP_USE_DEBUG */
		return;
	}

	BSP_LEDSigMode(LED_M_CLRALL);
	BSP_LEDSigMode(LED_M_CONNECTED_BAT_FULL);

	/* use clock generated by transceiver */
	EVBME_SwitchClock(pDeviceRef, APP_USE_EXTERNAL_CLOCK);

	if (BSP_IsUSBPresent())
		APP_STATE = APP_STATE_new = APP_ST_NORMAL;
	else
		APP_STATE = APP_STATE_new = APP_ST_DEVICE;

	TEMPSENSE_APP_SaveOrRestoreAddress(pDeviceRef);
	TEMPSENSE_APP_Initialise(pDeviceRef);

} // End of TEMPSENSE_Initialise()

/******************************************************************************/
/***************************************************************************/ /**
 * \brief Chili Event Handler in Main Polling Loop
 *******************************************************************************
 ******************************************************************************/
void TEMPSENSE_Handler(struct ca821x_dev *pDeviceRef)
{
	/* call application handler */
	TEMPSENSE_APP_Handler(pDeviceRef);
} // End of TEMPSENSE_Handler()

/******************************************************************************/
/***************************************************************************/ /**
 * \brief TEMPSENSE Dispatch Branch (UpStream, Serial)
 *******************************************************************************
 ******************************************************************************/
int TEMPSENSE_UpStreamDispatch(struct SerialBuffer *SerialRxBuffer, struct ca821x_dev *pDeviceRef)
{
	int ret;
	/* call application dispatch */
	if ((ret = TEMPSENSE_APP_UpStreamDispatch(SerialRxBuffer, pDeviceRef)))
	{
		return ret;
	}
	return 0;
} // End of TEMPSENSE_UpStreamDispatch()

/******************************************************************************/
/***************************************************************************/ /**
 * \brief button1_pressed called by GPIO ISR
 *******************************************************************************
 ******************************************************************************/
static int TEMPSENSE_mode_button_pressed(void)
{
	if (APP_STATE == APP_ST_NORMAL)
	{
		if (BSP_EnableUSB(), !BSP_IsUSBPresent())
			return 0;
		APP_STATE_new = APP_ST_COORDINATOR;
	}
	else if (APP_STATE == APP_ST_COORDINATOR)
	{
		BSP_DisableUSB();
		APP_STATE_new = APP_ST_DEVICE;
	}
	else
	{
		if (BSP_EnableUSB(), !BSP_IsUSBPresent())
			return 0;
		APP_STATE_new = APP_ST_NORMAL;
	}
	BSP_LEDSigMode(LED_M_CLRERROR);
	APP_INITIALISE = 1;
	return 0;
} // End of TEMPSENSE_mode_button_pressed()

/******************************************************************************/
/***************************************************************************/ /**
 * \brief usb_present_changed called by GPIO ISR
 *******************************************************************************
 ******************************************************************************/
static int TEMPSENSE_usb_present_changed(void)
{
	if (BSP_IsUSBPresent())
	{
		APP_STATE_new = APP_ST_NORMAL;
		BSP_LEDSigMode(LED_M_CLRERROR);
	}
	else
	{
		APP_STATE_new = APP_ST_DEVICE;
	}
	APP_INITIALISE = 1;
	return 0;
} // End of TEMPSENSE_usb_present_changed()

/******************************************************************************/
/***************************************************************************/ /**
 * \brief app_reinitialise called by BSP
 *******************************************************************************
 ******************************************************************************/
static int TEMPSENSE_reinitialise(struct ca821x_dev *pDeviceRef)
{
	EVBME_SwitchClock(pDeviceRef, APP_USE_EXTERNAL_CLOCK);
	TEMPSENSE_APP_InitPIB(pDeviceRef);
	if (APP_STATE == APP_ST_COORDINATOR)
		TEMPSENSE_APP_Coordinator_SoftReinit(pDeviceRef);
	BSP_LEDSigMode(LED_M_CLRERROR);
	return 0;
} // End of TEMPSENSE_reinitialise()

/******************************************************************************/
/***************************************************************************/ /**
 * \brief Callback for MCPS_DATA_indication in TEMPSENSE COORDINATOR Mode
 *******************************************************************************
 ******************************************************************************/
static ca_error TEMPSENSE_APP_COORD_MCPS_DATA_indication(struct MCPS_DATA_indication_pset *params,
                                                         struct ca821x_dev *               pDeviceRef)
{
	TEMPSENSE_APP_Coordinator_ProcessDataInd(params, pDeviceRef);
	return CA_ERROR_SUCCESS;
} // End of TEMPSENSE_APP_COORD_MCPS_DATA_indication()

/******************************************************************************/
/***************************************************************************/ /**
 * \brief Callback for MCPS_DATA_indication in TEMPSENSE DEVICE Mode
 *******************************************************************************
 ******************************************************************************/
static ca_error TEMPSENSE_APP_DEV_MCPS_DATA_indication(struct MCPS_DATA_indication_pset *params,
                                                       struct ca821x_dev *               pDeviceRef)
{
	TEMPSENSE_APP_Device_ProcessDataInd(params, pDeviceRef);
	return CA_ERROR_SUCCESS;
} // End of TEMPSENSE_APP_COORD_MCPS_DATA_indication()

/******************************************************************************/
/***************************************************************************/ /**
 * \brief Callback for MCPS_DATA_confirm in TEMPSENSE COORDINATOR Mode
 *******************************************************************************
 ******************************************************************************/
static ca_error TEMPSENSE_APP_COORD_MCPS_DATA_confirm(struct MCPS_DATA_confirm_pset *params,
                                                      struct ca821x_dev *            pDeviceRef)
{
	TEMPSENSE_APP_Coordinator_ProcessDataCnf(params, pDeviceRef);
	return CA_ERROR_SUCCESS;
} // End of TEMPSENSE_APP_COORD_MCPS_DATA_confirm()

/******************************************************************************/
/***************************************************************************/ /**
 * \brief Callback for MCPS_DATA_confirm in TEMPSENSE DEVICE Mode
 *******************************************************************************
 ******************************************************************************/
static ca_error TEMPSENSE_APP_DEV_MCPS_DATA_confirm(struct MCPS_DATA_confirm_pset *params,
                                                    struct ca821x_dev *            pDeviceRef)
{
	TEMPSENSE_APP_Device_ProcessDataCnf(params, pDeviceRef);
	return CA_ERROR_SUCCESS;
} // End of TEMPSENSE_APP_COORD_MCPS_DATA_confirm()

/******************************************************************************/
/***************************************************************************/ /**
 * \brief Callback for MLME_ASSOCIATE_indication in TEMPSENSE COORDINATOR Mode
 *******************************************************************************
 ******************************************************************************/
static ca_error TEMPSENSE_APP_COORD_MLME_ASSOCIATE_indication(struct MLME_ASSOCIATE_indication_pset *params,
                                                              struct ca821x_dev *                    pDeviceRef)
{
	if (APP_STATE == APP_ST_COORDINATOR)
	{
		TEMPSENSE_APP_Coordinator_AssociateResponse(params, pDeviceRef);
		return CA_ERROR_SUCCESS;
	}
	return CA_ERROR_NOT_HANDLED;
} // End of TEMPSENSE_APP_COORD_MLME_ASSOCIATE_indication()

/******************************************************************************/
/***************************************************************************/ /**
 * \brief Callback for MLME_COMM_STATUS_indication in TEMPSENSE COORDINATOR Mode
 *******************************************************************************
 ******************************************************************************/
static ca_error TEMPSENSE_APP_COORD_MLME_COMM_STATUS_indication(struct MLME_COMM_STATUS_indication_pset *params,
                                                                struct ca821x_dev *                      pDeviceRef)
{
	if (APP_STATE == APP_ST_COORDINATOR)
	{
		/* only supress message */
		if ((params->Status == MAC_SUCCESS) || (params->Status == MAC_TRANSACTION_EXPIRED))
		{
			return CA_ERROR_SUCCESS;
		}
	}
	return CA_ERROR_NOT_HANDLED;
} // End of TEMPSENSE_APP_COORD_MLME_COMM_STATUS_indication()

/******************************************************************************/
/***************************************************************************/ /**
 * \brief Callback for MLME_COMM_STATUS_indication in TEMPSENSE COORDINATOR Mode
 *******************************************************************************
 ******************************************************************************/
static ca_error TEMPSENSE_APP_COORD_HWME_WAKEUP_indication(struct HWME_WAKEUP_indication_pset *params,
                                                           struct ca821x_dev *                 pDeviceRef)
{
	if (APP_STATE == APP_ST_COORDINATOR)
	{
		/* only suppress message */
		return CA_ERROR_SUCCESS;
	}
	return CA_ERROR_NOT_HANDLED;
} // End of TEMPSENSE_APP_COORD_MLME_COMM_STATUS_indication()

/******************************************************************************/
/***************************************************************************/ /**
 * \brief Callback for MLME_ASSOCIATE_confirm in TEMPSENSE DEVICE Mode
 *******************************************************************************
 ******************************************************************************/
static ca_error TEMPSENSE_APP_DEV_MLME_ASSOCIATE_confirm(struct MLME_ASSOCIATE_confirm_pset *params,
                                                         struct ca821x_dev *                 pDeviceRef)
{
	TEMPSENSE_APP_Device_ProcessAssociateCnf(params, pDeviceRef);
	return CA_ERROR_SUCCESS;
} // End of TEMPSENSE_APP_DEV_MLME_ASSOCIATE_confirm()

/******************************************************************************/
/***************************************************************************/ /**
 * \brief Callback for MLME_SCAN_confirm in TEMPSENSE COORDINATOR Mode
 *******************************************************************************
 ******************************************************************************/
static ca_error TEMPSENSE_APP_COORD_MLME_SCAN_confirm(struct MLME_SCAN_confirm_pset *params,
                                                      struct ca821x_dev *            pDeviceRef)
{
	TEMPSENSE_APP_Coordinator_ProcessScanCnf(params, pDeviceRef);
	return CA_ERROR_SUCCESS;
} // End of TEMPSENSE_APP_COORD_MLME_SCAN_confirm()

/******************************************************************************/
/***************************************************************************/ /**
 * \brief Callback for MLME_SCAN_confirm in TEMPSENSE DEVICE Mode
 *******************************************************************************
 ******************************************************************************/
static ca_error TEMPSENSE_APP_DEV_MLME_SCAN_confirm(struct MLME_SCAN_confirm_pset *params,
                                                    struct ca821x_dev *            pDeviceRef)
{
	TEMPSENSE_APP_Device_ProcessScanCnf(params, pDeviceRef);
	return CA_ERROR_SUCCESS;
} // End of TEMPSENSE_APP_DEV_MLME_SCAN_confirm()

/******************************************************************************/
/***************************************************************************/ /**
 * \brief Dynamically Register Callbacks for TEMPSENSE
 *******************************************************************************
 ******************************************************************************/
void TEMPSENSE_RegisterCallbacks(struct ca821x_dev *pDeviceRef)
{
	if (APP_STATE == APP_ST_COORDINATOR)
	{
		pDeviceRef->callbacks.MCPS_DATA_indication        = &TEMPSENSE_APP_COORD_MCPS_DATA_indication;
		pDeviceRef->callbacks.MCPS_DATA_confirm           = &TEMPSENSE_APP_COORD_MCPS_DATA_confirm;
		pDeviceRef->callbacks.MLME_ASSOCIATE_indication   = &TEMPSENSE_APP_COORD_MLME_ASSOCIATE_indication;
		pDeviceRef->callbacks.MLME_COMM_STATUS_indication = &TEMPSENSE_APP_COORD_MLME_COMM_STATUS_indication;
		pDeviceRef->callbacks.HWME_WAKEUP_indication      = &TEMPSENSE_APP_COORD_HWME_WAKEUP_indication;
		pDeviceRef->callbacks.MLME_ASSOCIATE_confirm      = NULL;
		pDeviceRef->callbacks.MLME_SCAN_confirm           = &TEMPSENSE_APP_COORD_MLME_SCAN_confirm;
	}
	else if (APP_STATE == APP_ST_DEVICE)
	{
		pDeviceRef->callbacks.MCPS_DATA_indication        = &TEMPSENSE_APP_DEV_MCPS_DATA_indication;
		pDeviceRef->callbacks.MCPS_DATA_confirm           = &TEMPSENSE_APP_DEV_MCPS_DATA_confirm;
		pDeviceRef->callbacks.MLME_ASSOCIATE_indication   = NULL;
		pDeviceRef->callbacks.MLME_COMM_STATUS_indication = NULL;
		pDeviceRef->callbacks.HWME_WAKEUP_indication      = NULL;
		pDeviceRef->callbacks.MLME_ASSOCIATE_confirm      = &TEMPSENSE_APP_DEV_MLME_ASSOCIATE_confirm;
		pDeviceRef->callbacks.MLME_SCAN_confirm           = &TEMPSENSE_APP_DEV_MLME_SCAN_confirm;
	}
	else
	{
		pDeviceRef->callbacks.MCPS_DATA_indication        = NULL;
		pDeviceRef->callbacks.MCPS_DATA_confirm           = NULL;
		pDeviceRef->callbacks.MLME_ASSOCIATE_indication   = NULL;
		pDeviceRef->callbacks.MLME_COMM_STATUS_indication = NULL;
		pDeviceRef->callbacks.HWME_WAKEUP_indication      = NULL;
		pDeviceRef->callbacks.MLME_ASSOCIATE_confirm      = NULL;
		pDeviceRef->callbacks.MLME_SCAN_confirm           = NULL;
	}
} // End of TEMPSENSE_RegisterCallbacks()
