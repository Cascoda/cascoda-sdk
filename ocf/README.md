# OCF over Thread

This folder contains the platform code needed to make the OCF application
layer work on top of Thread, using our embedded Chili platform.

This document describes the existing OCF applications. If you would like to
create a custom application,
[there is a separate guide](../docs/dev/create-custom-ocf-applications.md#) for this.

The applications in this directory are compiled only if the `CASCODA_BUILD_OCF`
CMake cache variable is set to `ON`. Note that this will disable several other
targets vithin the SDK. If these are required, they must be built in a separate
binary directory.

Note that enabling `CASCODA_BUILD_OCF` disables the Test15-4 low-level debug interface globally,
which would break targets such as `mac-dongle` and also prevent running commands with Wing Commander.

## apps

The `apps` subdirectory contains a collection of OCF based example
applications.

### ocf-light

`ocf-light` is an OCF light server that can be used to control a lamp.
The application is using:

- wakeful_main.c, as main application
- example_light.c, as code for setting up IoTivity

The application can be compiled with the following command:
`make ocf-light`

This server contains the following resources:

- `oic.r.switch.binary` with url `/binaryswitch`.
- `oic.r.light.dimming` with url `/dimming`.

Pin 15 is mapped to the value of the `oic.r.switch.binary`.
The `oic.r.light.dimming` resource does not control anything.

The application is compiled with OCF security enabled, and it can be onboarded using JustWorks or PKI.

#### ocf-reed-light

`ocf-reed-light` is an OCF light server that can double as an OpenThread Router or Leader, as it is
a Router-enabled end device.

### ocf-sensorif

`ocf-sensorif` is an OCF sensor.
The application is using:

- wakeful_main.c, as main application
- example_sensorif.c, as code for setting up IoTivity

The application can be compiled with the following command:
`make ocf-sensorif`

This server contains the following resources:

- `oic.r.humidity` with url `/humidity`.
- `oic.r.sensor.illuminance` with url `/illuminance`.
- `oic.r.temperature` with url `/temperature`.

The humidity value is read from I2C using the supplied sensor interface.
The illuminance value is read from I2C using the supplied sensor interface.
The temperature value is read from I2C using the supplied sensor interface.

The application is compiled with
OCF security enabled, and it can be onboarded using JustWorks or PKI.

### ocf-cli-thermometer

`ocf-cli-thermometer` is an OCF sensor.

The application is using:

- wakeful_main.c, as main application
- example_thermometer.c, as code for setting up IoTivity

The application can be compiled with the following command:
`make ocf-cli-thermometer`

This server contains the following resources:

- `oic.r.temperature` with url `/temperature`.

The temperature value is read from chili module using the Board Support Package.

The application is compiled with
OCF security enabled, and it can be onboarded using JustWorks or PKI.

### ocf-sleepy-thermometer

`ocf-sleepy-thermometer` is an OCF sensor.

The application is using:

- sleepy_main.c, as main application
- example_thermometer.c, as code for setting up IoTivity

The application can be compiled with the following command:
`make ocf-sleepy-thermometer`

This server contains the following resources:

- `oic.r.temperature` with url `/temperature`.

The temperature value is read from chili module using the Board Support Package.

`ocf-sleepy-thermometer` is similar to `ocf-cli-thermometer`, except that it
is a Thread sleepy end device which turns off its radio when not in use in
order to conserve power. Consequently, this target takes longer to respond to
requests & updates - it has higher latency because the data is not sent until
the device wakes up and requests it from its parent.

The application is compiled with
OCF security enabled, and it can be onboarded using JustWorks or PKI.

## include_*

These folders contain header files which hold the introspection data for each
server. This data is necessary to pass OCF certification, and it is different
for every server. This data is automatically generated by [DeviceBuilder](https://openconnectivityfoundation.github.io/DeviceBuilder/) based
on the resource types passed to the program.
